	Similar to Project 2, Project 3 required us to use structs to track multiple car rental agencies and their inventory through a command line menu which provided multiple functions. We were restricted to only being able to use pointers to traverse arrays and we again had the requirement of having at least one value being passed by reference. The program need to be able to read in data from a file, store that data in their respective values within the structs, print the data to screen, give a rental cost estimate, print only the available cars, and find the most expensive car across the three agencies.
	When it came to Project 3, my biggest challenge was reading in the data and storing the data in the correct areas. One trick I learned, before it was discussed in lecture, was that the zip code for each agency is easier to store in the int array if it is first read in as a C style string and then converted into an int array, this was because if it was read in as an int, the first entry in the array would have some value such as ‘89507’, while the rest remained unassigned. My biggest issue was figuring out the syntax to reference a value within a struct through a pointer to the struct. After many many many compile attempts I decided to check the discussions and found my answer, that I needed to do (*structPointer).whateverVariable, so that first the pointer is dereferenced and then I can access the value. This issue extended when it came to accessing the int array within the struct, and I eventually learned that I needed to declare a separate int pointer to point to the int arrays location, which didn’t make sense at first, but I understood it the more it was used in the code. I had bugs pertaining to the pointers which are to be expected whenever it comes to working with them where I would access memory outside the bounds of the array, and other bugs where I wasn’t incrementing a pointer, so the same information was overwritten multiple times.
	Outside of the addition of pointers, the biggest difference between Project 3’s code and Project 2’s is that I created multiple PrintData functions. In Project 2, the PrintData function would change what it did depending on what one of the arguments were, while I think this was probably more efficient than Project 3’s solution of multiple functions, it made the code much more readable to me.
	Given more time I wouldn’t use pointers for a majority of the actions, but, assuming we would still need to stay within project requirements, I would have broken up a few of my larger functions into multiple smaller functions with the intent of shortening up the entire program. 

